<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Flying Spaghetti Monster</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section data-markdown>
                    <script type="text/template">
                        # Flying Spaghetti Monster

                        ## Verifying protocols with types and finite-state machines

                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)

                        Chris Ford ([@ctford](https://twitter.com/ctford)) - [ThoughtWorks](https://thoughtworks.com)

                        https://ctford.github.io/flying-spaghetti-monster
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Idris logo](img/idris-logo-small.png)

                        [Idris](https://www.idris-lang.org/) is a hipster functional programming language, a bit like Haskell/Scala/F#:
                        * The compiler checks the types.
                        * Functions are values.
                        * But also... *types are values*.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <img style="height: 600px" src="img/tdd-idris-cover.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Microservices
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Microservices do things in small pieces

                        * Data can be processed a bit at a time.
                        * Code can be changed a bit at a time.
                        * Systems can be understood a bit at a time.

                        We gain freedom at the cost of eventual consistency.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Greenspun's tenth rule of programming

                        Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ford's tenth rule of microservices

                        Any sufficiently complicated microservice architecture contains an ad-hoc, informally-specified, bug-ridden, slow implementation of a distributed protocol.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Finite-state Machines
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Finite-state Machines can model protocols

                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_cutoff.jpg) <img style="height: 386px" src="img/Door.png">

                        ['Touched By His Noodly Appendage' by Niklas Jansson (Public Domain)](https://commons.wikimedia.org/wiki/File:Touched_by_His_Noodly_Appendage_HD.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Networking code that implements a protocol
                        ```javascript
                                function doorProg() {
                                    door.open();
                                    door.knock();
                                    door.close();
                                }
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## ~~Indexed monads~~ Dominads specify a protocol

                        <style> .reveal pre { box-shadow: none;} </style>
                        <img style="float: left" src="img/Transitions.png">

                        ```haskell
                        -- A type defining what you can do with a door.
                        data DoorSession : Type -> (State, State) -> Type where

                            Knock : DoorSession () (Closed, Closed)
                            Close : DoorSession () (Open, Closed)
                            Open  : DoorSession () (Closed, Open)

                            (>>=) : DoorSession a (beginning, middle) ->
                                    (a -> DoorSession b (middle, end)) ->
                                    DoorSession b (beginning, end)
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## This does not compile!

                        ```haskell
                        -- Implement the door protocol incorrectly.
                        doorProg : DoorSession a (Closed, Closed)
                        doorProg = do Open
                                      Knock
                                      Close
                        ```
                        ![Doesn't compile](img/Uncompile.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## This compiles!

                        ```haskell
                        -- Implement the door protocol.
                        doorProg : DoorSession a (Closed, Closed)
                        doorProg = do Knock
                                      Open
                                      Close
                        ```
                        ![Compiles](img/Compile.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## "Types can't help us once the network gets involved"

                        1. Fallibility: how can I deal with failure?
                        2. Distribution: how do I communicate the protocol across a heterogeneous system?
                        3. Reciprocity: how do I turn a global protocol into local types?
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)

                        ['Touched By His Noodly Appendage' by Niklas Jansson (Public Domain)](https://commons.wikimedia.org/wiki/File:Touched_by_His_Noodly_Appendage_HD.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # 1. Fallibility
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Leo Tolstoy

                        "Happy families are all alike; every unhappy family is unhappy in its own way."
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Non-deterministic Finite-state Machines can model fallible protocols

                        <img style="height: 500px" src="img/Jam.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Specify a fallible protocol

                        ```haskell
                        -- A type defining what happens when you use a door.
                        data DoorSession : (result : Type) -> (State, result -> State) -> Type where

                            Knock : DoorSession () (Closed, const Closed)
                            Close : DoorSession () (Open, const Closed)
                            Open  : DoorSession () (Closed, \result => if (result == OK) then Open else Closed)

                            (>>=) : DoorSession a (beginning, choose-next) ->
                                  ((result : a) -> DoorSession b (choose-next result) finally) ->
                                  DoorSession b beginning finally
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Error checking is enforced

                        ```haskell
                        -- Implement the fallible door protocol.
                        door : DoorSession a (Closed, const Closed)
                        door = do Knock
                                  Ok <- Open | Failure => Nothing
                                  Close
                        ```
                        ![Compiles even with nondeterminism](img/Nondeterminism.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # 2. Distribution
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Type providers

                        * Borrowed from F#.
                        * Hook into the compiler.
                        * Generate types from external sources.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## The types are generated

                        Text protocol description...

                                #name         from        to         on-error
                                insert-coin   waiting     paid
                                return        paid        waiting
                                select        paid        selected   paid
                                vend          selected    waiting

                        ...consumed as types

                        ```haskell
                        -- Import a vending machine type.
                        %provide (VendingMachineSession : (Route -> Type)) with Protocol "vending-machine.txt"

                        vendingMachine : VendingMachineSession ("waiting", const "waiting")
                        vendingMachine = do
                            Do "insert-coin"
                            Ok <- Try "select" | Failure => Do "return"
                            Do "vend"
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # 3. Reciprocity
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Session types

                        * Represent a multi-party interaction as a type.
                        * Project the global type into a local type for each participant.
                        * Verify the global protocol via local checks.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Reciprocal sessions

                        ```haskell
                        -- Flip a series of session states.
                        dual : SessionState -> SessionState
                        dual (Out x remainder) = In x (dual remainder)
                        dual (In x remainder)  = Out x (dual remainder)
                        dual Empty             = Empty
                        ```

                        ```haskell
                        Server : Type -> SessionState -> Type
                        Server a start = Session a (start, Empty)

                        Client : Type -> SessionState -> Type
                        Client a start = Session a ((dual start), Empty)
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Conclusion
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        We're building systems we don't fully understand.

                        We need better ways to think about systems with many, fallible moving parts.

                        ~~Types can't help us once the network gets involved.~~

                        Types can help us once the network gets involved.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Where to go next

                        ![Connected sessions](img/Next.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## References

                        * [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)
                        * [Idris homepage](https://www.idris-lang.org)
                        * [Type Providers in Idris](http://docs.idris-lang.org/en/latest/guides/type-providers-ffi.html)
                        * [Multiparty Asynchronous Session Types](http://www.doc.ic.ac.uk/~yoshida/multiparty/multiparty.pdf)
                        * [Haskell Session Types with (Almost) No Class](http://users.eecs.northwestern.edu/~jesse/pubs/haskell-session-types/session08.pdf)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)

                        https://ctford.github.io/flying-spaghetti-monster

                        https://github.com/ctford/flying-spaghetti-monster
                    </script>
                </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                margin: 0,
                width: 1600,
                height: 1024,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>

