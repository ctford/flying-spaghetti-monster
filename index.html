<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Flying Spaghetti Monster</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section data-markdown>
                    <script type="text/template">
                        # Flying Spaghetti Monster

                        [@ctford](https://twitter.com/ctford)/[ThoughtWorks](https://thoughtworks.com)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## The Flying Spaghetti Monster

                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)

                        [Image by Niklas Jansson (Public Domain)](https://commons.wikimedia.org/wiki/File:Touched_by_His_Noodly_Appendage_HD.jpg).
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Idris logo](img/idris-logo-small.png)

                        Idris is from the Haskell family of functional languages:

                        * The compiler checks the types.
                        * Functions are values.
                        * *Types* are values.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <img style="height: 600px" src="img/tdd-idris-cover.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Idris example

                        ```haskell
                                -- Define the concatenate function.
                                concatenate : Vect n a -> Vect m a -> Vect (n + m) a
                                concatenate []        ys = ys
                                concatenate (x :: xs) ys = x :: concatenate xs ys

                                -- Use it.
                                concatenate [1, 2, 3] [4, 5, 6]
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Microservices
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Microservices let you do things in small pieces.

                        * Data can be processed a bit at a time.
                        * Code can be changed a bit at a time.
                        * Systems can be understood a bit at a time.

                        We gain freedom at the cost of eventual consistency.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Greenspun's tenth rule of programming

                        Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ford's tenth rule of programming

                        Any sufficiently complicated microservice architecture contains an ad-hoc, informally-specified, bug-ridden, slow implementation of a distributed protocol.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Finite State Machines
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Finite State Machines can model protocols

                        <img style="height: 500px" src="img/door-state-machine.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Networking code that implements a FSM
                        ```javascript
                                function doorProg() {
                                    door.open();
                                    door.knock();
                                    door.close();
                                }
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Specify a FSM

                        ```haskell
                        -- A type defining what you can do with a door.
                        data DoorSession : (State, State) -> Type where
                            Open  : DoorSession (Closed, Open)
                            Close : DoorSession (Open, Closed)
                            Knock : DoorSession (Closed, Closed)
                            (>>=) : DoorSession (beginning, middle) ->
                                    (a -> DoorSession (middle, end)) ->
                                    DoorSession (beginning, end)

                        -- Example usage.
                        doorProg : DoorSession (Closed, Closed)
                        doorProg = do Open; Knock; Close -- This would not compile!
                        doorProg = do Knock; Open; Close -- This works just fine.
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Fallibility
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## But... a conversation has two sides.

                        What if the door jams?
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Leo Tolstoy

                        Happy families are all alike; every unhappy family is unhappy in its own way.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Finite State Machines can model protocols

                        <img style="height: 500px" src="img/door-state-machine.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Specify a fallible FSM

                        ```haskell
                        -- A type defining what happens when you use a door.
                        data DoorSession : (result : Type) -> (State, result -> State) -> Type where
                            Open : DoorSession () (Closed, \x => if (x == OK) then Open else Closed)
                            Close : DoorSession () (Open, const Closed)
                            Knock : DoorSession () (Closed, const Closed)
                            (>>=) : DoorSession a (beginning, next) ->
                                ((result : a) -> DoorSession b (next result) finally) ->
                                DoorSession b beginning finally
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Discoverability
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Type providers can let an external schema drive your types.

                                #name       from      to       alternate
                                insert-coin waiting   paid
                                insert-coin paid      paid
                                return      paid      waiting
                                select      paid      selected paid
                                vend        selected  waiting

                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Error states can be checked

                        ```haskell
                        -- Import a vending machine session type.
                        %provide (VendingMachineSession : (Route -> Type)) with Protocol "vending-machine.txt"

                        -- Use the session type.
                        vendingMachine : VendingMachineSession ("waiting", const "waiting")
                        vendingMachine = do
                            Do "insert-coin"
                            Do "insert-coin"
                            Success <- Try "select" | Failure => do Do "return"; Fail
                            Do "vend"
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Conclusion
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        We're building systems we don't fully understand.

                        We need better ways to think about systems with many, fallible moving parts.

                        Expressive type systems can help.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## References

                        * [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)
                        * [Idris homepage](https://www.idris-lang.org)
                        * [Type Providers in Idris](http://docs.idris-lang.org/en/latest/guides/type-providers-ffi.html)
                        * [Multiparty Asynchronous Session Types](http://www.doc.ic.ac.uk/~yoshida/multiparty/multiparty.pdf)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                margin: 0,
                width: 1600,
                height: 1024,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>

