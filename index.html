<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Flying Spaghetti Monster</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section data-markdown>
                    <script type="text/template">
                        # Flying Spaghetti Monster

                        ## Verifying protocols with types and finite-state machines

                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)

                        Chris Ford ([@ctford](https://twitter.com/ctford)) - [ThoughtWorks](https://thoughtworks.com)

                        https://ctford.github.io/flying-spaghetti-monster
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <img style="background-color: white" src="img/idris-logo-small.png">

                        [Idris](https://www.idris-lang.org/) is a hipster functional programming language, a bit like Haskell/Scala/F#:
                        * The compiler checks the types.
                        * Functions are values.
                        * But also... **types are values**.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <img style="height: 600px" src="img/tdd-idris-cover.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Microservices
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Microservices do things in small pieces

                        * Data can be processed a bit at a time.
                        * Code can be changed a bit at a time.
                        * Systems can be understood a bit at a time.

                        We gain freedom at the cost of eventual consistency.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Greenspun's tenth rule of programming

                        Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ford's tenth rule of microservices

                        Any sufficiently complicated microservice architecture contains an ad-hoc, informally-specified, bug-ridden, slow implementation of a distributed protocol.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        Narrative isn't enough.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Finite-state Machines
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Finite-state Machines can model protocols

                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_cutoff.jpg) <img style="height: 386px" src="img/Door.png">

                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Networking code that implements a protocol
                        ```javascript
                        function doorProg(door) {
                            door.open();
                            door.knock();
                            door.close();
                        }
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## ~~Indexed monads~~ Dominads specify a protocol

                        Each transition is paramatised by its **return type**, its **entry state** and its **exit state**.

                        ```haskell
                        -- A type defining what you can do with a door.
                        data DoorSession : (result : Type) -> (State, State) -> Type where

                            Knock : DoorSession () (Closed, Closed)
                            Close : DoorSession () (Opened, Closed)
                            Open  : DoorSession () (Closed, Opened)

                            (>>=) : DoorSession a (beginning, middle) ->
                                    (a -> DoorSession b (middle, end)) ->
                                    DoorSession b (beginning, end)
                        ```
                        <img src="img/Transitions.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## This does not compile!

                        ```haskell
                        -- Implement the door protocol incorrectly.
                        doorProg : DoorSession a (Closed, Closed)
                        doorProg = do
                            Open
                            Knock
                            Close
                        ```
                        ![Doesn't compile](img/Uncompile.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## This compiles!

                        ```haskell
                        -- Implement the door protocol.
                        doorProg : DoorSession a (Closed, Closed)
                        doorProg = do
                            Knock
                            Open
                            Close
                        ```
                        ![Compiles](img/Compile.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## "Types can't help us once the network gets involved"

                        1. Fallibility: how can I deal with failure?
                        2. Distribution: how can I communicate the protocol across a heterogeneous system?
                        3. Reciprocity: how can I turn a global protocol into local expectations?
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # 1. Fallibility
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Leo Tolstoy

                        "Happy families are all alike; every unhappy family is unhappy in its own way."
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Non-deterministic Finite-state Machines can model fallible protocols

                        <img style="height: 500px" src="img/Jam.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Specify a fallible protocol

                        Each transition is paramatised by its **return type**, its **entry state** and **a function choosing its exit state**.

                        ```haskell
                        -- A type defining what happens when you use a door.
                        data DoorSession : (result : Type) -> (State, result -> State) -> Type where

                            Knock : DoorSession ()   (Closed, const Closed)
                            Close : DoorSession ()   (Opened, const Closed)
                            Open  : DoorSession Bool (Closed, \successful => if successful then Opened else Closed)

                            (>>=) : DoorSession a (beginning, choose) ->
                                    ((result : a) -> DoorSession b (choose result) finally) ->
                                    DoorSession b beginning finally
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Error checking is enforced

                        ```haskell
                        -- Implement the fallible door protocol.
                        doorProg : DoorSession a (Closed, const Closed)
                        doorProg = do
                            Knock
                            True <- Open | False => DoNothing
                            Close
                        ```
                        ![Compiles even with nondeterminism](img/Nondeterminism.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # 2. Distribution
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Type providers

                        * Borrowed from F#.
                        * Hook into the compiler.
                        * Generate types from external sources.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## The types are generated

                        Text protocol description...

                        ```markdown
                        #name         from        to         on-error
                        insert-coin   waiting     paid
                        return-coin   paid        waiting
                        select        paid        selected   paid
                        vend          selected    waiting
                        ```

                        ...consumed as types

                        ```haskell
                        -- Import a vending machine type.
                        %provide (VendingMachineSession : (Route -> Type)) with Protocol "vending-machine.txt"

                        vendingMachine : VendingMachineSession ("waiting", const "waiting")
                        vendingMachine = do
                            Do "insert-coin"
                            True <- Try "select" | False => Do "return-coin"
                            Do "vend"
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # 3. Reciprocity
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Session types

                        * Represent a multi-party interaction as a type.
                        * Project the global type into a local type for each participant.
                        * Verify the global protocol via local checks.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Reciprocal sessions

                        ```haskell
                        -- Flip a series of session states.
                        dual : SessionState -> SessionState
                        dual (Out x remainder) = In x (dual remainder)
                        dual (In x remainder)  = Out x (dual remainder)
                        dual Empty             = Empty
                        ```

                        ```haskell
                        Server : Type -> SessionState -> Type
                        Server a start = Session a (start, Empty)

                        Client : Type -> SessionState -> Type
                        Client a start = Session a ((dual start), Empty)
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Conclusion
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        We're building systems we don't fully understand.

                        We need better ways to think about systems with many, fallible moving parts.

                        ~~Types can't help us once the network gets involved.~~

                        Types can help us once the network gets involved.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Where to go next

                        ![Connected sessions](img/Next.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## References

                        * [Haskell Session Types with (Almost) No Class](http://users.eecs.northwestern.edu/~jesse/pubs/haskell-session-types/session08.pdf) by Pucella and Tov
                        * [Idris homepage](https://www.idris-lang.org)
                        * [Idris Type Providers documentation](http://docs.idris-lang.org/en/latest/guides/type-providers-ffi.html)
                        * [Multiparty Asynchronous Session Types](http://www.doc.ic.ac.uk/~yoshida/multiparty/multiparty.pdf) by Honda, Yoshida and Carbone
                        * [Paramatised Notions of Computation](http://www.bcs.org/upload/pdf/ewic_ms06_paper5.pdf) by Atkey
                        * [Touched By His Noodly Appendage](https://commons.wikimedia.org/wiki/File:Touched_by_His_Noodly_Appendage_HD.jpg) by Jansson
                        * [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris) by Brady
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)

                        https://ctford.github.io/flying-spaghetti-monster

                        https://github.com/ctford/flying-spaghetti-monster
                    </script>
                </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                margin: 0,
                width: 1600,
                height: 1024,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
