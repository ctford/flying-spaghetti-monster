<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Flying Spaghetti Monster</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section data-markdown>
                    <script type="text/template">
                        # Flying Spaghetti Monster

                        ## Verifying protocols with types and finite-state machines

                        Chris Ford ([@ctford](https://twitter.com/ctford)) - [ThoughtWorks](https://thoughtworks.com)

                        https://ctford.github.io/flying-spaghetti-monster
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## The Flying Spaghetti Monster

                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)

                        [Image by Niklas Jansson (Public Domain)](https://commons.wikimedia.org/wiki/File:Touched_by_His_Noodly_Appendage_HD.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Idris logo](img/idris-logo-small.png)

                        [Idris](https://www.idris-lang.org/) is a hipster functional programming language, a bit like Haskell/Scala/F#:
                        * The compiler checks the types.
                        * Functions are values.
                        * *Types* are values.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <img style="height: 600px" src="img/tdd-idris-cover.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Idris example

                        ```haskell
                                -- Define the concatenate function.
                                concatenate : Vect n a -> Vect m a -> Vect (n + m) a
                                concatenate []        ys = ys
                                concatenate (x :: xs) ys = x :: concatenate xs ys

                                -- Use it.
                                concatenate [1, 2, 3] [4, 5, 6]
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        Problem of today, wonder from the future.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Microservices
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Microservices do things in small pieces

                        * Data can be processed a bit at a time.
                        * Code can be changed a bit at a time.
                        * Systems can be understood a bit at a time.

                        We gain freedom at the cost of eventual consistency.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Greenspun's tenth rule of programming

                        Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ford's tenth rule of microservices

                        Any sufficiently complicated microservice architecture contains an ad-hoc, informally-specified, bug-ridden, slow implementation of a distributed protocol.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Finite-state Machines
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Finite-state Machines can model protocols

                        <img style="height: 500px" src="img/door-state-machine.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Networking code that implements a protocol
                        ```javascript
                                function doorProg() {
                                    door.open();
                                    door.knock();
                                    door.close();
                                }
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Specify a protocol

                        ```haskell
                        -- A type defining what you can do with a door.
                        data DoorSession : (State, State) -> Type where

                            Open  : DoorSession (Closed, Open)

                            Close : DoorSession (Open, Closed)

                            Knock : DoorSession (Closed, Closed)

                            (>>=) : DoorSession (beginning, middle) ->
                                    (a -> DoorSession (middle, end)) ->
                                    DoorSession (beginning, end)
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## This does not compile!

                        ```haskell
                        -- Implement the door protocol incorrectly.
                        doorProg : DoorSession (Closed, Closed)
                        doorProg = do Open
                                      Knock
                                      Close
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## This compiles!

                        ```haskell
                        -- Implement the door protocol.
                        doorProg : DoorSession (Closed, Closed)
                        doorProg = do Knock
                                      Open
                                      Close
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Fallibility
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## A conversation has two sides

                        What if the door jams?
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Leo Tolstoy

                        Happy families are all alike; every unhappy family is unhappy in its own way.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Finite-state Machines can model protocols

                        <img style="height: 500px" src="img/door-state-machine.png">
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Specify a fallible protocol

                        ```haskell
                        -- A type defining what happens when you use a door.
                        data DoorSession : (result : Type) -> (State, result -> State) -> Type where

                            Open : DoorSession () (Closed, \result => if (result == OK) then Open else Closed)

                            Close : DoorSession () (Open, const Closed)

                            Knock : DoorSession () (Closed, const Closed)

                            (>>=) : DoorSession a (beginning, choose-next) ->
                                  ((result : a) -> DoorSession b (choose-next result) finally) ->
                                  DoorSession b beginning finally
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Error checking is enforced

                        ```haskell
                        -- Implement the fallible door protocol.
                        doorProg : DoorSession (Closed, const Closed)
                        doorProg = do Knock
                                      Ok <- Open | Failure => Nothing
                                      Close
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Distribution
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Type providers

                        * Borrowed from F#.
                        * Hook into the compiler.
                        * Generate types from external sources.
                        * Reduce boilerplate.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## A protocol as a text file

                                #name         from        to         on-error
                                insert-coin   waiting     paid
                                insert-coin   paid        paid
                                return        paid        waiting
                                select        paid        selected   paid
                                vend          selected    waiting

                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Error checking is enforced

                        ```haskell
                        -- Import a vending machine session type.
                        %provide (VendingMachineSession : (Route -> Type)) with Protocol "vending-machine.txt"

                        -- Implement the session type.
                        vendingMachineProg : VendingMachineSession ("waiting", const "waiting")
                        vendingMachineProg = do
                            Do "insert-coin"
                            Do "insert-coin"
                            Ok <- Try "select" | Failure => Do "return"
                            Do "vend"
                        ```
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ![Touched By His Noodly Appendage](img/Touched_by_His_Noodly_Appendage_800.jpg)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        # Conclusion
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        We're building systems we don't fully understand.

                        We need better ways to think about systems with many, fallible moving parts.

                        Expressive type systems can help.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## References

                        * [FSM proof-of-concept](https://github.com/ctford/flying-spaghetti-monster)
                        * [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)
                        * [Idris homepage](https://www.idris-lang.org)
                        * [Type Providers in Idris](http://docs.idris-lang.org/en/latest/guides/type-providers-ffi.html)
                        * [Multiparty Asynchronous Session Types](http://www.doc.ic.ac.uk/~yoshida/multiparty/multiparty.pdf)
                    </script>
                </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                margin: 0,
                width: 1600,
                height: 1024,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>

